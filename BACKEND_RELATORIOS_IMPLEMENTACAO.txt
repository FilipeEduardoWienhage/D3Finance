================================================================================
                    IMPLEMENTAÇÃO BACKEND - SISTEMA DE RELATÓRIOS
================================================================================

Este arquivo contém toda a implementação necessária para o backend do sistema
de relatórios inteligentes com modelos pré-definidos.

================================================================================
1. CONTROLLER DE RELATÓRIOS
================================================================================

Arquivo: d3-finance-api/d3_finance_api/src/api/v1/endpoints/relatorios_controller.py

```python
from datetime import date, datetime
from typing import Annotated, List, Optional
from fastapi import HTTPException, Depends, status, Response, Query
from sqlalchemy import extract, func, and_
from sqlalchemy.orm import Session
from src.app import router
from src.database.database import SessionLocal
from src.database.models import Receitas, Despesas, Contas, Usuario, Transacoes
from src.api.tags import Tag
from src.schemas.relatorios_schemas import (
    RelatorioMensalResponse, 
    RelatorioTrimestralResponse,
    RelatorioAnualResponse,
    RelatorioFluxoCaixaResponse,
    RelatorioPersonalizadoRequest,
    RelatorioPersonalizadoResponse
)
from src.services.autenticacao_service import get_current_user
from src.schemas.autenticacao_schemas import TokenData

# Endpoints
RELATORIO_MENSAL = "/v1/relatorios/mensal"
RELATORIO_TRIMESTRAL = "/v1/relatorios/trimestral"
RELATORIO_ANUAL = "/v1/relatorios/anual"
RELATORIO_FLUXO_CAIXA = "/v1/relatorios/fluxo-caixa"
RELATORIO_PERSONALIZADO = "/v1/relatorios/personalizado"

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@router.get(
    path=RELATORIO_MENSAL,
    response_model=RelatorioMensalResponse,
    tags=[Tag.Relatorios.name]
)
def get_relatorio_mensal(
    usuario_logado: Annotated[TokenData, Depends(get_current_user)],
    db: Session = Depends(get_db),
    ano: int = Query(..., description="Ano do relatório"),
    mes: int = Query(..., description="Mês do relatório (1-12)")
):
    """Gera relatório mensal consolidado"""
    if not 1 <= mes <= 12:
        raise HTTPException(status_code=400, detail="Mês deve estar entre 1 e 12")
    
    # Calcular período
    data_inicio = date(ano, mes, 1)
    if mes == 12:
        data_fim = date(ano + 1, 1, 1) - date.resolution
    else:
        data_fim = date(ano, mes + 1, 1) - date.resolution
    
    # Buscar receitas do período
    receitas = db.query(
        func.sum(Receitas.valor_recebido).label('total'),
        func.count(Receitas.id).label('quantidade')
    ).filter(
        and_(
            Receitas.usuario_id == usuario_logado.id,
            Receitas.data_recebimento >= data_inicio,
            Receitas.data_recebimento <= data_fim
        )
    ).first()
    
    # Buscar despesas do período
    despesas = db.query(
        func.sum(Despesas.valor_pago).label('total'),
        func.count(Despesas.id).label('quantidade')
    ).filter(
        and_(
            Despesas.usuario_id == usuario_logado.id,
            Despesas.data_pagamento >= data_inicio,
            Despesas.data_pagamento <= data_fim
        )
    ).first()
    
    # Receitas por categoria
    receitas_categoria = db.query(
        Receitas.categoria,
        func.sum(Receitas.valor_recebido).label('valor')
    ).filter(
        and_(
            Receitas.usuario_id == usuario_logado.id,
            Receitas.data_recebimento >= data_inicio,
            Receitas.data_recebimento <= data_fim
        )
    ).group_by(Receitas.categoria).all()
    
    # Despesas por categoria
    despesas_categoria = db.query(
        Despesas.categoria,
        func.sum(Despesas.valor_pago).label('valor')
    ).filter(
        and_(
            Despesas.usuario_id == usuario_logado.id,
            Despesas.data_pagamento >= data_inicio,
            Despesas.data_pagamento <= data_fim
        )
    ).group_by(Despesas.categoria).all()
    
    total_receitas = receitas.total or 0.0
    total_despesas = despesas.total or 0.0
    saldo_periodo = total_receitas - total_despesas
    margem_lucro = (saldo_periodo / total_receitas * 100) if total_receitas > 0 else 0
    
    return RelatorioMensalResponse(
        periodo_inicio=data_inicio,
        periodo_fim=data_fim,
        total_receitas=total_receitas,
        total_despesas=total_despesas,
        saldo_periodo=saldo_periodo,
        margem_lucro=round(margem_lucro, 2),
        receitas_por_categoria=[
            {"categoria": r.categoria, "valor": float(r.valor)} 
            for r in receitas_categoria
        ],
        despesas_por_categoria=[
            {"categoria": d.categoria, "valor": float(d.valor)} 
            for d in despesas_categoria
        ],
        quantidade_receitas=receitas.quantidade or 0,
        quantidade_despesas=despesas.quantidade or 0
    )

@router.get(
    path=RELATORIO_TRIMESTRAL,
    response_model=RelatorioTrimestralResponse,
    tags=[Tag.Relatorios.name]
)
def get_relatorio_trimestral(
    usuario_logado: Annotated[TokenData, Depends(get_current_user)],
    db: Session = Depends(get_db),
    ano: int = Query(..., description="Ano do relatório"),
    trimestre: int = Query(..., description="Trimestre (1-4)")
):
    """Gera relatório trimestral consolidado"""
    if not 1 <= trimestre <= 4:
        raise HTTPException(status_code=400, detail="Trimestre deve estar entre 1 e 4")
    
    # Calcular meses do trimestre
    mes_inicio = (trimestre - 1) * 3 + 1
    mes_fim = trimestre * 3
    
    # Buscar dados dos 3 meses
    dados_trimestre = []
    for mes in range(mes_inicio, mes_fim + 1):
        data_inicio = date(ano, mes, 1)
        if mes == 12:
            data_fim = date(ano + 1, 1, 1) - date.resolution
        else:
            data_fim = date(ano, mes + 1, 1) - date.resolution
        
        # Receitas do mês
        receitas_mes = db.query(func.sum(Receitas.valor_recebido)).filter(
            and_(
                Receitas.usuario_id == usuario_logado.id,
                Receitas.data_recebimento >= data_inicio,
                Receitas.data_recebimento <= data_fim
            )
        ).scalar() or 0.0
        
        # Despesas do mês
        despesas_mes = db.query(func.sum(Despesas.valor_pago)).filter(
            and_(
                Despesas.usuario_id == usuario_logado.id,
                Despesas.data_pagamento >= data_inicio,
                Despesas.data_pagamento <= data_fim
            )
        ).scalar() or 0.0
        
        dados_trimestre.append({
            "mes": mes,
            "receitas": float(receitas_mes),
            "despesas": float(despesas_mes),
            "lucro": float(receitas_mes - despesas_mes)
        })
    
    return RelatorioTrimestralResponse(
        ano=ano,
        trimestre=trimestre,
        dados_mensais=dados_trimestre
    )

@router.get(
    path=RELATORIO_ANUAL,
    response_model=RelatorioAnualResponse,
    tags=[Tag.Relatorios.name]
)
def get_relatorio_anual(
    usuario_logado: Annotated[TokenData, Depends(get_current_user)],
    db: Session = Depends(get_db),
    ano: int = Query(..., description="Ano do relatório")
):
    """Gera relatório anual consolidado"""
    data_inicio = date(ano, 1, 1)
    data_fim = date(ano, 12, 31)
    
    # Totais anuais
    total_receitas = db.query(func.sum(Receitas.valor_recebido)).filter(
        and_(
            Receitas.usuario_id == usuario_logado.id,
            Receitas.data_recebimento >= data_inicio,
            Receitas.data_recebimento <= data_fim
        )
    ).scalar() or 0.0
    
    total_despesas = db.query(func.sum(Despesas.valor_pago)).filter(
        and_(
            Despesas.usuario_id == usuario_logado.id,
            Despesas.data_pagamento >= data_inicio,
            Despesas.data_pagamento <= data_fim
        )
    ).scalar() or 0.0
    
    # Receitas por mês
    receitas_mensais = db.query(
        extract('month', Receitas.data_recebimento).label('mes'),
        func.sum(Receitas.valor_recebido).label('valor')
    ).filter(
        and_(
            Receitas.usuario_id == usuario_logado.id,
            Receitas.data_recebimento >= data_inicio,
            Receitas.data_recebimento <= data_fim
        )
    ).group_by(extract('month', Receitas.data_recebimento)).all()
    
    # Despesas por mês
    despesas_mensais = db.query(
        extract('month', Despesas.data_pagamento).label('mes'),
        func.sum(Despesas.valor_pago).label('valor')
    ).filter(
        and_(
            Despesas.usuario_id == usuario_logado.id,
            Despesas.data_pagamento >= data_inicio,
            Despesas.data_pagamento <= data_fim
        )
    ).group_by(extract('month', Despesas.data_pagamento)).all()
    
    # Organizar dados por mês
    dados_mensais = []
    for mes in range(1, 13):
        receita_mes = next((r.valor for r in receitas_mensais if r.mes == mes), 0.0)
        despesa_mes = next((d.valor for d in despesas_mensais if d.mes == mes), 0.0)
        dados_mensais.append({
            "mes": mes,
            "receitas": float(receita_mes),
            "despesas": float(despesa_mes),
            "lucro": float(receita_mes - despesa_mes)
        })
    
    return RelatorioAnualResponse(
        ano=ano,
        total_receitas=float(total_receitas),
        total_despesas=float(total_despesas),
        lucro_liquido=float(total_receitas - total_despesas),
        margem_lucro=round((total_receitas - total_despesas) / total_receitas * 100, 2) if total_receitas > 0 else 0,
        dados_mensais=dados_mensais
    )

@router.get(
    path=RELATORIO_FLUXO_CAIXA,
    response_model=RelatorioFluxoCaixaResponse,
    tags=[Tag.Relatorios.name]
)
def get_relatorio_fluxo_caixa(
    usuario_logado: Annotated[TokenData, Depends(get_current_user)],
    db: Session = Depends(get_db),
    data_inicio: date = Query(..., description="Data de início do período"),
    data_fim: date = Query(..., description="Data de fim do período")
):
    """Gera relatório de fluxo de caixa"""
    # Fluxo operacional
    entradas_caixa = db.query(func.sum(Receitas.valor_recebido)).filter(
        and_(
            Receitas.usuario_id == usuario_logado.id,
            Receitas.data_recebimento >= data_inicio,
            Receitas.data_recebimento <= data_fim
        )
    ).scalar() or 0.0
    
    saidas_caixa = db.query(func.sum(Despesas.valor_pago)).filter(
        and_(
            Despesas.usuario_id == usuario_logado.id,
            Despesas.data_pagamento >= data_inicio,
            Despesas.data_pagamento <= data_fim
        )
    ).scalar() or 0.0
    
    # Saldos das contas
    saldo_inicial = db.query(func.sum(Contas.saldo)).filter(
        Contas.usuario_id == usuario_logado.id
    ).scalar() or 0.0
    
    saldo_final = saldo_inicial + entradas_caixa - saidas_caixa
    
    return RelatorioFluxoCaixaResponse(
        periodo_inicio=data_inicio,
        periodo_fim=data_fim,
        entradas_caixa=float(entradas_caixa),
        saidas_caixa=float(saidas_caixa),
        fluxo_operacional=float(entradas_caixa - saidas_caixa),
        saldo_inicial=float(saldo_inicial),
        saldo_final=float(saldo_final)
    )

@router.post(
    path=RELATORIO_PERSONALIZADO,
    response_model=RelatorioPersonalizadoResponse,
    tags=[Tag.Relatorios.name]
)
def gerar_relatorio_personalizado(
    request: RelatorioPersonalizadoRequest,
    usuario_logado: Annotated[TokenData, Depends(get_current_user)],
    db: Session = Depends(get_db)
):
    """Gera relatório personalizado baseado nos parâmetros fornecidos"""
    # Aqui você pode implementar lógica personalizada baseada nos parâmetros
    # Por exemplo, filtrar dados por categorias específicas, períodos, etc.
    
    return RelatorioPersonalizadoResponse(
        titulo=request.titulo,
        conteudo=request.conteudo,
        dados_adicionais=request.dados_adicionais,
        conclusoes=request.conclusoes,
        data_geracao=datetime.now()
    )
```

================================================================================
2. SCHEMAS DE RELATÓRIOS
================================================================================

Arquivo: d3-finance-api/d3_finance_api/src/schemas/relatorios_schemas.py

```python
from typing import List, Optional, Dict, Any
from datetime import date, datetime
from pydantic import BaseModel, Field

class CategoriaValor(BaseModel):
    categoria: str
    valor: float

    class Config:
        from_attributes = True

class DadosMensais(BaseModel):
    mes: int
    receitas: float
    despesas: float
    lucro: float

    class Config:
        from_attributes = True

# Relatório Mensal
class RelatorioMensalResponse(BaseModel):
    periodo_inicio: date
    periodo_fim: date
    total_receitas: float
    total_despesas: float
    saldo_periodo: float
    margem_lucro: float
    receitas_por_categoria: List[CategoriaValor]
    despesas_por_categoria: List[CategoriaValor]
    quantidade_receitas: int
    quantidade_despesas: int

    class Config:
        from_attributes = True

# Relatório Trimestral
class RelatorioTrimestralResponse(BaseModel):
    ano: int
    trimestre: int
    dados_mensais: List[DadosMensais]

    class Config:
        from_attributes = True

# Relatório Anual
class RelatorioAnualResponse(BaseModel):
    ano: int
    total_receitas: float
    total_despesas: float
    lucro_liquido: float
    margem_lucro: float
    dados_mensais: List[DadosMensais]

    class Config:
        from_attributes = True

# Relatório de Fluxo de Caixa
class RelatorioFluxoCaixaResponse(BaseModel):
    periodo_inicio: date
    periodo_fim: date
    entradas_caixa: float
    saidas_caixa: float
    fluxo_operacional: float
    saldo_inicial: float
    saldo_final: float

    class Config:
        from_attributes = True

# Relatório Personalizado
class RelatorioPersonalizadoRequest(BaseModel):
    titulo: str = Field(..., description="Título do relatório")
    conteudo: str = Field(..., description="Conteúdo principal do relatório")
    dados_adicionais: Optional[str] = Field(None, description="Dados adicionais relevantes")
    conclusoes: Optional[str] = Field(None, description="Conclusões do relatório")

class RelatorioPersonalizadoResponse(BaseModel):
    titulo: str
    conteudo: str
    dados_adicionais: Optional[str]
    conclusoes: Optional[str]
    data_geracao: datetime

    class Config:
        from_attributes = True
```

================================================================================
3. ATUALIZAR ARQUIVO DE TAGS
================================================================================

Arquivo: d3-finance-api/d3_finance_api/src/api/tags.py

```python
from enum import Enum

class Tag(str, Enum):
    Usuarios = "Usuarios"
    Autenticacao = "Autenticacao"
    Contas = "Contas"
    Receitas = "Receitas"
    Despesas = "Despesas"
    Transacoes = "Transacoes"
    ContasReceber = "ContasReceber"
    Importacao = "Importacao"
    Recuperacao = "Recuperacao"
    Telegram = "Telegram"
    Relatorios = "Relatorios"  # Nova tag adicionada
```

================================================================================
4. INSTRUÇÕES DE IMPLEMENTAÇÃO
================================================================================

1. Crie o arquivo relatorios_controller.py na pasta:
   d3-finance-api/d3_finance_api/src/api/v1/endpoints/

2. Crie o arquivo relatorios_schemas.py na pasta:
   d3-finance-api/d3_finance_api/src/schemas/

3. Atualize o arquivo tags.py para incluir a nova tag "Relatorios"

4. Reinicie o servidor backend para que as novas rotas sejam reconhecidas

5. Teste os endpoints usando o Swagger UI (geralmente em /docs)

================================================================================
5. ENDPOINTS DISPONÍVEIS APÓS IMPLEMENTAÇÃO
================================================================================

GET /v1/relatorios/mensal?ano=2024&mes=12
- Gera relatório mensal consolidado

GET /v1/relatorios/trimestral?ano=2024&trimestre=4
- Gera relatório trimestral consolidado

GET /v1/relatorios/anual?ano=2024
- Gera relatório anual consolidado

GET /v1/relatorios/fluxo-caixa?data_inicio=2024-01-01&data_fim=2024-12-31
- Gera relatório de fluxo de caixa

POST /v1/relatorios/personalizado
- Gera relatório personalizado baseado nos parâmetros fornecidos

================================================================================
6. ESTRUTURA DE DADOS RETORNADA
================================================================================

Todos os relatórios retornam dados estruturados com:
- Períodos de análise
- Valores consolidados (receitas, despesas, lucros)
- Dados agrupados por categoria
- Métricas calculadas (margem de lucro, etc.)
- Dados temporais organizados

================================================================================
7. AUTENTICAÇÃO
================================================================================

Todos os endpoints requerem autenticação via token JWT.
O usuário logado é obtido automaticamente via get_current_user.

================================================================================
8. FILTROS E PARÂMETROS
================================================================================

- Relatórios mensais: ano e mês
- Relatórios trimestrais: ano e trimestre (1-4)
- Relatórios anuais: ano
- Fluxo de caixa: data_inicio e data_fim
- Personalizado: dados via body da requisição

================================================================================
9. PRÓXIMOS PASSOS
================================================================================

Após implementar o backend:
1. Teste todos os endpoints
2. Implemente o frontend (service e componente)
3. Conecte o frontend com o backend
4. Teste a funcionalidade completa
5. Adicione validações adicionais se necessário

================================================================================
FIM DA IMPLEMENTAÇÃO BACKEND
================================================================================ 